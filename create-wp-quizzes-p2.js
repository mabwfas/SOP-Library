const fs = require('fs');
const fp = './sops/training/wordpress-training-data.js';
let c = fs.readFileSync(fp, 'utf8');

const task8Quiz = [
    // Security & Hardening
    { q: "A form accepts user input and directly inserts it into a SQL query. This vulnerability is:", o: ["Cross-Site Scripting — the input could contain JavaScript that executes when other users view the page content", "SQL Injection — unsanitized input can modify the query structure, allowing attackers to read, modify, or delete database data", "CSRF — the form doesn't verify the origin of the request which allows forged submissions from external sites", "Brute force — the form allows unlimited submission attempts which can be exploited to guess valid input values"], c: 1 },
    { q: "WordPress nonces protect against CSRF. Where should you verify a nonce?", o: ["In the HTML form's action attribute — WordPress checks nonces automatically when forms submit to admin-post.php", "In the handler function processing the form/AJAX request — using wp_verify_nonce() before executing any data changes", "In wp-config.php as a global security setting that applies to all forms and AJAX requests across the entire site", "In the browser's JavaScript console — nonces are client-side tokens that the browser validates before sending requests"], c: 1 },
    { q: "sanitize_text_field() vs esc_html() — when to use which:", o: ["They're identical functions — WordPress provides both for backward compatibility but they produce the same output", "sanitize_text_field() cleans INPUT going INTO the database, esc_html() escapes OUTPUT being displayed to the user — sanitize input, escape output", "sanitize_text_field() is for admin users while esc_html() is for frontend visitors based on the user role context", "Both are deprecated in WordPress 6.0 — use wp_safe_data() for all sanitization and escaping needs in modern development"], c: 1 },
    { q: "A client's admin URL is example.com/wp-admin. A security hardening step is:", o: ["Move all admin files to a custom directory since WordPress supports relocating wp-admin to any folder path natively", "Change the login URL using a security plugin, implement fail2ban or login attempt limiting, and ensure strong passwords are enforced", "WordPress admin URLs cannot be changed — focus security efforts on other areas like SSL certificates and server firewalls", "Rename wp-admin to admin — this single change prevents 90% of automated attacks without any additional security measures"], c: 1 },
    { q: "$wpdb->prepare() is critical in custom queries because:", o: ["It caches query results for faster subsequent database access, reducing the number of queries on high-traffic pages", "It parameterizes queries — separating SQL structure from user data prevents SQL injection, even with malicious input values", "It's optional syntactic sugar that makes code more readable but doesn't provide any actual security or performance benefits", "It converts all queries to use WordPress transient API instead of direct database access for better performance scaling"], c: 1 },
    { q: "File permissions on wp-config.php should be set to:", o: ["777 — giving full read/write/execute to all users ensures WordPress can always access its configuration without permission errors", "440 or 400 — owner read only, preventing the web server process from modifying the file while still allowing PHP to read it", "666 — read/write for everyone since WordPress needs to update its own configuration during automatic security updates", "755 — standard directory permissions that work for all WordPress files including configuration and media upload files"], c: 1 },
    { q: "A plugin uses wp_update_post() with unvalidated user data. The risk is:", o: ["No risk — wp_update_post() automatically sanitizes all data before writing to the database in WordPress core functions", "Privilege escalation — an attacker could modify post_author, post_status, or post_type fields to change ownership or publish unauthorized content", "Performance degradation — wp_update_post() is slow with large data payloads and should be replaced with direct SQL for speed", "WordPress will reject the update automatically if any field contains characters that could trigger a security vulnerability"], c: 1 },
    { q: "SSL/HTTPS for WordPress sites should be:", o: ["Optional for sites without e-commerce — blogs and portfolio sites don't handle sensitive data that requires encryption", "Mandatory — FORCE_SSL_ADMIN in wp-config.php plus site-wide HTTPS redirect protects login credentials, cookies, and user trust", "Configured only on the wp-admin pages — frontend pages don't transmit sensitive data and mixed content warnings won't appear", "Handled entirely by the hosting provider — WordPress developers should never configure SSL settings at the application level"], c: 1 },
    { q: "Two-factor authentication (2FA) for WordPress admin accounts:", o: ["Adds unnecessary friction to the login process and should be reserved for high-security government or banking websites", "Is a critical layer — even if passwords are compromised, 2FA prevents unauthorized access until the second factor is verified", "Is built into WordPress core since version 5.0 and doesn't require any additional plugins or configuration to enable", "Slows down admin operations significantly because every single action in the dashboard requires re-authentication"], c: 1 },
    { q: "During a security audit, you find a theme echoing $_GET['search'] directly in HTML. The fix is:", o: ["Replace with esc_html(sanitize_text_field($_GET['search'])) — sanitize the input AND escape the output to prevent XSS attacks", "Wrap it in htmlspecialchars() once — this is sufficient since it handles all possible XSS attack vectors in user input", "Remove the search feature entirely — accepting user input via URL parameters is inherently insecure in all circumstances", "Add a disclaimer that the search may contain HTML — informing users about potential risks satisfies security requirements"], c: 0 },
];

const task9Quiz = [
    // Performance Optimization
    { q: "A WordPress site scores 35 on PageSpeed. The FIRST optimization step should be:", o: ["Install a caching plugin immediately — caching solves 90% of WordPress performance issues regardless of the root cause", "Audit the cause — check server response time, image sizes, render-blocking resources, and excessive plugins before applying fixes", "Upgrade the hosting plan — low PageSpeed scores are always caused by insufficient server resources and slow hardware", "Remove all plugins — WordPress core alone scores 100 on PageSpeed and every plugin reduces the score proportionally"], c: 1 },
    { q: "Lazy loading images means:", o: ["Compressing all images to 50% quality during upload to reduce file sizes regardless of the original image dimensions", "Images below the viewport load only when the user scrolls to them — reducing initial page weight and improving LCP on content-heavy pages", "Serving all images as WebP format since it's the smallest file format for all image types regardless of content", "Loading images from an external CDN instead of the local server to distribute bandwidth across multiple data centers"], c: 1 },
    { q: "A site has 45 active plugins. The performance impact is:", o: ["Minimal — WordPress is designed to handle unlimited plugins without any measurable impact on page load time or memory", "Each plugin adds PHP execution time, database queries, and potentially CSS/JS files — 45 plugins likely causes significant overhead and conflicts", "Exactly 45ms added per page load — each plugin adds approximately 1ms of overhead according to WordPress benchmarks", "No impact on frontend — plugins only affect wp-admin performance and the public-facing site loads independently"], c: 1 },
    { q: "Object caching with Redis or Memcached improves WordPress performance by:", o: ["Compressing database tables to reduce disk storage usage and improve read/write speeds for all SQL queries", "Storing frequently accessed database query results in memory — eliminating repeated identical queries on every page load", "Replacing MySQL entirely — object caches serve as a complete database replacement for WordPress in production environments", "Only caching static HTML files — dynamic content like logged-in user dashboards cannot benefit from object caching"], c: 1 },
    { q: "Core Web Vitals LCP (Largest Contentful Paint) measures:", o: ["How quickly the entire page finishes loading including all asynchronous JavaScript execution and third-party scripts", "The time until the largest visible element (hero image, heading) renders — Google uses this as a ranking factor for search results", "The number of layout shifts during page load that cause visual instability and frustrate users trying to interact", "Total blocking time during which the browser's main thread is occupied and unable to respond to user input events"], c: 1 },
    { q: "wp_enqueue_script with 'in_footer' => true improves performance because:", o: ["Footer scripts are automatically minified by WordPress while header scripts maintain their original uncompressed format", "Scripts in the footer don't block HTML parsing — the browser renders visible content first, then loads JavaScript, reducing perceived load time", "Footer scripts are loaded asynchronously on all browsers while header scripts always load synchronously blocking rendering", "It makes no difference — WordPress loads all scripts at the same time regardless of the footer parameter setting value"], c: 1 },
    { q: "A CDN (Content Delivery Network) helps WordPress performance by:", o: ["Serving static assets from geographically distributed servers — users download images, CSS, and JS from the nearest edge server, reducing latency", "Running WordPress PHP code on multiple servers simultaneously to distribute the processing load across data centers", "Automatically optimizing WordPress database queries by caching SQL results at the network edge close to end users", "Replacing the web server entirely — CDNs handle all HTTP requests including dynamic WordPress content generation"], c: 0 },
    { q: "Autoptimize or WP Rocket's 'combine CSS/JS' feature helps performance by:", o: ["Making the code more readable by organizing multiple files into a single well-structured file for development purposes", "Reducing HTTP requests — instead of loading 15 separate CSS files, the browser loads 1 combined and minified file per category", "Automatically rewriting CSS and JavaScript code to use modern syntax that browsers execute faster than legacy code", "It hurts performance on HTTP/2 — combining files was beneficial for HTTP/1.1 but modern servers serve multiple files efficiently"], c: 1 },
    { q: "WordPress image optimization should include:", o: ["Uploading original camera images (5000px, 4MB each) and letting WordPress handle all resizing automatically at runtime", "Serving appropriately sized images, using modern formats like WebP, implementing srcset for responsive loading, and compressing during upload", "Converting all images to SVG format since vector graphics scale infinitely without quality loss for all image types", "Using CSS to visually resize large images — the display size is what matters for performance, not the file downloaded"], c: 1 },
    { q: "WordPress transients API is useful for performance because:", o: ["Transients permanently store data in wp_options, providing a faster alternative to wp_postmeta for all data storage needs", "Transients cache expensive operations (API calls, complex queries) with automatic expiration — reducing repeated processing on subsequent requests", "They're identical to WordPress options but with a shorter function name for developer convenience in writing cleaner code", "Transients store data in browser cookies, reducing server-side processing by moving computation to the client device"], c: 1 },
];

const task10Quiz = [
    // REST API & Headless WordPress
    { q: "The WordPress REST API base URL for fetching all published posts is:", o: ["example.com/api/posts — WordPress uses a simple path structure for all API endpoints without any versioning scheme", "example.com/wp-json/wp/v2/posts — the wp-json route exposes versioned endpoints for all WordPress content types", "example.com/wp-admin/api/posts — all API routes are served through the admin directory for security access control", "example.com/rest/posts — WordPress REST routes use the /rest/ prefix to differentiate from standard page URLs"], c: 1 },
    { q: "register_rest_route() creates a custom API endpoint. The 'permission_callback' parameter:", o: ["Is optional and defaults to allowing all requests — omitting it exposes the endpoint publicly without any restrictions", "Controls WHO can access the endpoint — returning true for public, checking current_user_can() for authenticated routes", "Defines the HTTP method (GET, POST, PUT) that the route responds to for proper RESTful API design patterns", "Specifies the data format returned — JSON for web clients, XML for mobile apps, based on the permission level"], c: 1 },
    { q: "Headless WordPress with React/Next.js means:", o: ["Removing the WordPress admin panel entirely and managing content through the React application's built-in CMS features", "WordPress serves as a content API backend only — the frontend is a separate React/Next.js app consuming data via REST API or WPGraphQL", "Installing React as a WordPress plugin that replaces the default theme with a single-page application framework", "Using WordPress block editor (Gutenberg) to generate React components automatically from the post content blocks"], c: 1 },
    { q: "WP REST API authentication for a custom mobile app should use:", o: ["The admin username and password sent as URL parameters — this is the simplest authentication method for API access", "Application Passwords or JWT tokens — OAuth-style tokens that don't expose the user's actual WordPress login credentials", "Cookie authentication — the mobile app should maintain WordPress session cookies identical to browser-based login", "No authentication needed — REST API endpoints are designed to be publicly accessible for all client applications"], c: 1 },
    { q: "A custom REST endpoint returns sensitive user data. The minimum security should include:", o: ["HTTPS only — encryption alone is sufficient since the data can't be intercepted during transmission across networks", "Permission callback checking user capabilities, nonce verification for browser requests, and data sanitization before response — defense in depth", "Rate limiting only — preventing too many requests is the primary security concern for API endpoints serving data", "IP whitelisting — restricting API access to specific IP addresses is the only reliable method for securing endpoints"], c: 1 },
    { q: "The wp/v2/posts endpoint returns 10 posts by default. To get all posts, the query parameter is:", o: ["?all=true — this flag overrides the default pagination and returns every post in a single response without limits", "?per_page=100 (max 100) with pagination headers — X-WP-TotalPages tells you how many pages exist for complete traversal", "?limit=0 — setting the limit to zero removes all pagination restrictions and returns the complete dataset at once", "?no_pagination=1 — this WordPress-specific parameter disables the built-in pagination system for the API request"], c: 1 },
    { q: "WPGraphQL vs REST API — the key advantage of GraphQL for headless WordPress:", o: ["GraphQL is faster because it bypasses PHP entirely and queries the database directly using optimized SQL generated automatically", "GraphQL lets clients specify exactly which fields they need — reducing over-fetching compared to REST which returns all fields always", "GraphQL eliminates the need for authentication since its query language includes built-in security at the schema level", "REST API is deprecated in WordPress core — WPGraphQL is the official replacement for all API-based interactions"], c: 1 },
    { q: "wp_send_json_success() and wp_send_json_error() in custom endpoints:", o: ["Are WordPress wrapper functions that structure JSON responses with consistent success/error format and set proper content-type headers", "Can only be used in AJAX handlers — REST API endpoints must use echo json_encode() for sending JSON response data", "Are deprecated since WordPress 5.0 — use WP_REST_Response class exclusively for all JSON output in modern endpoints", "Are identical functions — WordPress uses the function name only for developer readability with no behavioral difference"], c: 0 },
    { q: "CORS (Cross-Origin Resource Sharing) matters for headless WordPress because:", o: ["CORS is only relevant for same-domain requests — headless frontends always run on the same domain as WordPress backend", "The React/Next.js frontend runs on a different domain than WordPress — without CORS headers, the browser blocks cross-origin API requests", "WordPress automatically configures CORS for all domains — developers never need to handle cross-origin configuration manually", "CORS is a server-side security feature — the browser ignores CORS headers and allows all cross-origin requests natively"], c: 1 },
    { q: "REST API custom endpoints should sanitize and validate arguments using:", o: ["JavaScript validation on the frontend — preventing invalid data from being sent is more efficient than server-side validation", "The 'args' parameter with 'sanitize_callback' and 'validate_callback' — WordPress validates input before the endpoint handler executes", "Global sanitization in wp-config.php — all API input is automatically sanitized based on site-wide security configuration", "Manual validation inside the callback function only — WordPress argument definitions don't support built-in validation features"], c: 1 },
];

const task11Quiz = [
    // Deployment & Final Exam
    { q: "The staging-to-production deployment workflow at Digital Heroes requires:", o: ["Copy files directly via FTP from the staging server to production since it's the fastest transfer method available", "Full deployment pipeline: staging testing, client approval, database migration, DNS verification, then production push — never skip steps", "Deploy to production first, then test — fixing issues on live is faster than maintaining a separate staging environment", "Only theme files need deployment — WordPress core, plugins, and database remain identical between staging and production always"], c: 1 },
    { q: "A pre-launch QA checklist should include:", o: ["Only visual checks — if the site looks correct on desktop, it passes QA and is ready for production deployment immediately", "Cross-browser testing, mobile responsiveness, form submissions, 404 pages, SSL certificate, meta tags, analytics, and speed scores — comprehensive coverage", "Checking that the content matches the design mockup — functionality testing is the client's responsibility post-launch", "Running a single PageSpeed test — a score above 50 means the site is production-ready for client handover and launch"], c: 1 },
    { q: "Database migration from staging to production — the critical step is:", o: ["Export SQL and import directly — database URLs, paths, and serialized data will work automatically across environments", "Use WP-CLI or a migration tool to search-replace staging URLs with production URLs — serialized data requires proper deserialization handling", "Manually update each URL in phpMyAdmin — automated tools can corrupt WordPress database content during migration processing", "Skip database migration — install WordPress fresh on production and manually recreate all content and settings from staging"], c: 1 },
    { q: "WordPress backups before deployment should include:", o: ["Only the database — WordPress core files can be reinstalled and themes can be redownloaded from the marketplace easily", "Complete backup: database + wp-content (themes, plugins, uploads) — restoring BOTH is required for full site recovery after deployment failure", "Only the theme directory — plugins and uploads are stored externally and don't need local backup copies before deployment", "Backups aren't necessary with Git version control — reverting commits achieves the same result as restoring from backup files"], c: 1 },
    { q: "After deployment, the client reports 'mixed content' warnings. This means:", o: ["The site has multiple languages mixed on the same page which confuses browsers into displaying a security warning", "HTTPS pages are loading some resources (images, scripts, CSS) via HTTP — all resources must use HTTPS for a fully secure page", "The WordPress database collation is mismatched between tables causing character encoding issues in the page output", "CSS files are conflicting with JavaScript files creating rendering issues that browsers report as mixed content errors"], c: 1 },
    { q: "WP-CLI's role in professional WordPress deployment:", o: ["WP-CLI is a graphical tool for managing WordPress through a visual interface without needing to access the server terminal", "Command-line interface for automating updates, migrations, database operations, and configuration — essential for scripted deployment pipelines", "WP-CLI is only for local development and cannot be used on production servers due to security restrictions in hosting environments", "It replaces the WordPress admin dashboard entirely — once WP-CLI is installed, wp-admin becomes inaccessible and unnecessary"], c: 1 },
    { q: "Uptime monitoring for a deployed WordPress site should:", o: ["Be checked manually once a week by visiting the site in a browser to confirm it loads correctly without any errors", "Use automated tools that ping the site every 1-5 minutes and alert immediately via SMS/Slack when downtime is detected", "Rely on the hosting provider's monitoring — it's their responsibility to ensure the server and WordPress site remain online", "Be configured only for the first week after launch — once a site is stable it won't experience unexpected downtime events"], c: 1 },
    { q: "A deployment breaks the site. The FIRST recovery step is:", o: ["Start debugging the issue on the live production server to identify and fix the problem before users notice the downtime", "Restore from the pre-deployment backup IMMEDIATELY to minimize downtime, then debug the issue on staging before redeploying", "Contact the hosting provider for emergency support since deployment rollbacks require server-level access and permissions", "Clear the browser cache and try again — most deployment issues are caused by cached content rather than actual errors"], c: 1 },
    { q: "WordPress site maintenance after launch includes:", o: ["Nothing — once a site is launched it's the client's responsibility to manage all updates, security, and content maintenance", "Regular core/plugin/theme updates, security scans, performance monitoring, backup verification, and uptime checks — ongoing professional maintenance", "Only content updates — WordPress core updates automatically and plugins don't need manual intervention after initial installation", "Annual reviews — checking the site once a year for updates is sufficient since WordPress is inherently stable and secure"], c: 1 },
    { q: "DNS propagation after changing nameservers can take up to:", o: ["Instant — DNS changes take effect immediately once saved in the domain registrar's control panel across all networks", "24-48 hours — DNS records are cached by ISPs worldwide and each must refresh independently, causing variable propagation delays", "5 minutes — modern DNS infrastructure uses real-time propagation that ensures global availability within minutes of any change", "7 days — the standard DNS TTL is set to one week for all domain registrars as an industry-wide default configuration"], c: 1 },
];

const quizVars = { task8Quiz, task9Quiz, task10Quiz, task11Quiz };

for (const [name, questions] of Object.entries(quizVars)) {
    const qStr = questions.map(q => {
        const opts = q.o.map(o => `"${o.replace(/"/g, '\\"')}"`).join(', ');
        return `    { q: "${q.q.replace(/"/g, '\\"')}", o: [${opts}], c: ${q.c} }`;
    }).join(',\n');

    const varDef = `const ${name} = [\n${qStr}\n];\n`;

    const aqIdx = c.indexOf('const allQuizzes');
    c = c.substring(0, aqIdx) + varDef + '\n' + c.substring(aqIdx);
    console.log(`✅ ${name} (${questions.length}q)`);
}

// Update allQuizzes to reference all vars
c = c.replace(
    /const allQuizzes = \[[\s\S]*?\];/,
    `const allQuizzes = [
    task0Quiz,
    task2Quiz,
    task3Quiz,
    task4Quiz,
    task5Quiz,
    task6Quiz,
    task7Quiz,
    task8Quiz,
    task9Quiz,
    task10Quiz,
    task11Quiz
];`
);

fs.writeFileSync(fp, c);
console.log('\nPart 2 done — tasks 8-11 written');
console.log('Total new quizzes: 100 questions across 10 tasks');
